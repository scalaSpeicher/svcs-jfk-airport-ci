import {
  computed,
  createBaseVNode,
  createCommentVNode,
  createElementBlock,
  mergeProps,
  normalizeClass,
  openBlock,
  renderSlot,
  toRefs,
  vShow,
  withDirectives,
  withKeys,
  withModifiers
} from "./chunk-GPXMV72R.js";
import "./chunk-5WWUZCGV.js";

// node_modules/@vueform/toggle/dist/toggle.js
var b = { name: "Toggle", emits: ["input", "update:modelValue", "change"], props: { ...{ value: { validator: function(e) {
  return (e2) => -1 !== ["number", "string", "boolean"].indexOf(typeof e2) || null == e2;
}, required: false }, modelValue: { validator: function(e) {
  return (e2) => -1 !== ["number", "string", "boolean"].indexOf(typeof e2) || null == e2;
}, required: false } }, id: { type: [String, Number], required: false, default: "toggle" }, name: { type: [String, Number], required: false, default: "toggle" }, disabled: { type: Boolean, required: false, default: false }, required: { type: Boolean, required: false, default: false }, falseValue: { type: [String, Number, Boolean], required: false, default: false }, trueValue: { type: [String, Number, Boolean], required: false, default: true }, onLabel: { type: [String, Object], required: false, default: "" }, offLabel: { type: [String, Object], required: false, default: "" }, classes: { type: Object, required: false, default: () => ({}) }, labelledby: { type: String, required: false }, describedby: { type: String, required: false }, aria: { required: false, type: Object, default: () => ({}) } }, setup(a, d) {
  const n = function(a2, d2, n2) {
    const { value: t2, modelValue: u2, falseValue: i2, trueValue: c, disabled: r } = toRefs(a2), o = u2 && void 0 !== u2.value ? u2 : t2, s = computed(() => o.value === c.value), g = (e) => {
      d2.emit("input", e), d2.emit("update:modelValue", e), d2.emit("change", e);
    }, b2 = () => {
      g(c.value);
    }, f2 = () => {
      g(i2.value);
    };
    return -1 !== [null, void 0, false, 0, "0", "off"].indexOf(o.value) && -1 === [i2.value, c.value].indexOf(o.value) && f2(), -1 !== [true, 1, "1", "on"].indexOf(o.value) && -1 === [i2.value, c.value].indexOf(o.value) && b2(), { externalValue: o, checked: s, update: g, check: b2, uncheck: f2, handleInput: (e) => {
      g(e.target.checked ? c.value : i2.value);
    }, handleClick: () => {
      r.value || (s.value ? f2() : b2());
    } };
  }(a, d), t = function(a2, d2, n2) {
    const { trueValue: t2, falseValue: u2, onLabel: i2, offLabel: c } = toRefs(a2), r = n2.checked, o = n2.update;
    return { label: computed(() => {
      let e = r.value ? i2.value : c.value;
      return e || (e = "&nbsp;"), e;
    }), toggle: () => {
      o(r.value ? u2.value : t2.value);
    }, on: () => {
      o(t2.value);
    }, off: () => {
      o(u2.value);
    } };
  }(a, 0, { checked: n.checked, update: n.update }), u = function(a2, d2, n2) {
    const t2 = toRefs(a2), u2 = t2.disabled, i2 = n2.checked, c = computed(() => ({ container: "toggle-container", toggle: "toggle", toggleOn: "toggle-on", toggleOff: "toggle-off", toggleOnDisabled: "toggle-on-disabled", toggleOffDisabled: "toggle-off-disabled", handle: "toggle-handle", handleOn: "toggle-handle-on", handleOff: "toggle-handle-off", handleOnDisabled: "toggle-handle-on-disabled", handleOffDisabled: "toggle-handle-off-disabled", label: "toggle-label", ...t2.classes.value }));
    return { classList: computed(() => ({ container: c.value.container, toggle: [c.value.toggle, u2.value ? i2.value ? c.value.toggleOnDisabled : c.value.toggleOffDisabled : i2.value ? c.value.toggleOn : c.value.toggleOff], handle: [c.value.handle, u2.value ? i2.value ? c.value.handleOnDisabled : c.value.handleOffDisabled : i2.value ? c.value.handleOn : c.value.handleOff], label: c.value.label })) };
  }(a, 0, { checked: n.checked }), i = function(l, a2, d2) {
    const { disabled: n2 } = toRefs(l), t2 = d2.check, u2 = d2.uncheck, i2 = d2.checked;
    return { handleSpace: () => {
      n2.value || (i2.value ? u2() : t2());
    } };
  }(a, 0, { check: n.check, uncheck: n.uncheck, checked: n.checked });
  return { ...n, ...u, ...t, ...i };
} };
var f = ["tabindex", "aria-checked", "aria-describedby", "aria-labelledby"];
var h = ["id", "name", "value", "checked", "disabled"];
var v = ["innerHTML"];
var p = ["checked"];
b.render = function(e, l, b2, k, y, O) {
  return openBlock(), createElementBlock("div", mergeProps({ class: e.classList.container, tabindex: b2.disabled ? void 0 : 0, "aria-checked": e.checked, "aria-describedby": b2.describedby, "aria-labelledby": b2.labelledby, role: "switch" }, b2.aria, { onKeypress: l[1] || (l[1] = withKeys(withModifiers((...l2) => e.handleSpace && e.handleSpace(...l2), ["prevent"]), ["space"])) }), [withDirectives(createBaseVNode("input", { type: "checkbox", id: b2.id, name: b2.name, value: b2.trueValue, checked: e.checked, disabled: b2.disabled }, null, 8, h), [[vShow, false]]), createBaseVNode("div", { class: normalizeClass(e.classList.toggle), onClick: l[0] || (l[0] = (...l2) => e.handleClick && e.handleClick(...l2)) }, [createBaseVNode("span", { class: normalizeClass(e.classList.handle) }, null, 2), renderSlot(e.$slots, "label", { checked: e.checked, classList: e.classList }, () => [createBaseVNode("span", { class: normalizeClass(e.classList.label), innerHTML: e.label }, null, 10, v)]), b2.required ? (openBlock(), createElementBlock("input", { key: 0, type: "checkbox", style: { appearance: "none", height: "1px", margin: "0", padding: "0", fontSize: "0", background: "transparent", position: "absolute", width: "100%", bottom: "0", outline: "none" }, checked: e.checked, "aria-hidden": "true", tabindex: "-1", required: "" }, null, 8, p)) : createCommentVNode("v-if", true)], 2)], 16, f);
}, b.__file = "src/Toggle.vue";
export {
  b as default
};
//# sourceMappingURL=@vueform_toggle.js.map
